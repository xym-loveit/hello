[TOC]

# 多线程的基本知识
#### 线程：
在同一个进程中同时存在的多个程序控制流。线程会共享进程的资源包括内存句柄和文件句柄，并且每个线程都有自己的程序计数器、栈以及局部变量。正是因为在同一个进程中所有的线程都将共享进程的内存数据，所以如果不采用某种同步机制，那么多个线程访问或修改同一个变量时就会出现问题。

#### 多线程的好处：  
我们知道线程是靠CPU调度的。如果一个程序是单线程执行的，那么在同一时刻只能允许执行一个程序也就是占用整个的CPU资源。如果CPU是双核的那就意味着单线程程序只占用一半的CPU资源。这对于程序来说就是大大的资源浪费。所以我们在开发多线程程序的目的，就是通过提高处理器的利用率来提高系统的运行效率。

#### 竞态条件：  
由于不恰当的执行顺序而出现的不正确的结果。也就是说程序的正确性取决于多个线程的交替执行那么就会发生竞态条件。说白了就是程序正确的运行结果要取决于运气。

#### 数据竞争：  
当多线程访问共享的变量时就会出现数据竞争。当一个线程更改一个变量而另一个线程读取这个变量，并且两个线程之间没有同步，那么就会出现数据竞争。

#### 内置锁（监视器锁、互斥锁）：  
在Java中设置了一种内置锁来解决线程的安全问题，也就是同步代码块synchronized。任何一个Java对象都可以做为一个同步代码块的锁。线程在进入同步代码块之前会自动获得锁，在退出同步代码块之时会自动释放锁。这些锁就叫做内置锁、监视器锁或互斥锁。互斥的意义在于在同一时刻最多只能有一个线程获取到锁。当线程1获取到锁时，线程2只能等待阻塞，如果现线1一直不释放锁，那么线程2将一直等待下去。

#### 原子性：  
一组语句作为一个不可分割的单元被执行。正是因为如此所以被同步代码块保护的代码将以原子的方式运行。

#### 内置锁的重入：  
我们知道当一个线程试图请求另一个线程持有的锁时，那么当前线程就会阻塞。但是内置锁是可重入的，如果一个线程试图获取一个自己持有的锁时，那么这个请求就会成功而并不会阻塞。内置锁重入的底层实现逻辑是：为每一个锁都关联一个计数值和锁的持有者。当计数器为0的时候，就被认为这个锁没有被任何线程获取。当线程请求一个未被持有的锁时，JVM就会记录锁的持有者也就是当前线程，并且将计数器的值修改为1。如果同一个线程再次获取锁时，那么计数器就会递增。而当线程退出同步代码块时，计数器就会递减，当计数时为0时，当前线程持有的锁也就会被释放。
